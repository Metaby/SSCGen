/*
 *	Conventions:
 *	isel = input-select
 *	asel = address-select
 *	csel = command-select
 *
 *	Fields and Parameters:
 *	pcReg_write[0:0] = {H, L}
 *	pcReg_isel[1:1] = {pcInc.out, pcReg.out}
 *	mpcReg_write[2:2] = {H, L}
 *	mpcReg_isel[3:3] = {mpcInc.out, progMem.out}
 *	op1_register_write[4:4] = {H, L}
 *	op2_register_write[5:5] = {H, L}
 *	stackPtr_write[6:6] = {H, L}
 *	stackPtr_isel[7:7] = {stackAlu.out, stackPtr.out}
 *	output_write[8:8] = {H, L}
 *	stack_port0_isel[9:10] = {math.low, math.high, progMem.out}
 *	stack_port0_write[11:11] = {H, L}
 *	math_csel[12:13] = {ADD_U, MUL_U, SUB_U}
 *	stackAlu_csel[14:14] = {ADD_U, SUB_U}
 */

definition processors/stack_machine/stack_machine_microprogram.def

/*
	Initialisierungssequenz für die Stack-Maschine
*/
function init(0x00) {
	fix mpcReg_write(H);														// Fixiere mpcReg_write damit das Register mit jedem Takt schreibt
	set mpcReg_isel(progMem.out);												// Springe zu Mikrocode für ersten Befehl	
}

/*
	Lädt eine Konstante aus dem Programspeicher
*/
function loadConstant(0x10) {
	call incPc();																// Erhöhe den PC für den Zugriff auf die Konstante
	set stack_port0_isel(progMem.out), stack_port0_write(H);					// Speicher die Konstante aus dem Programmspeicher in den Stack
	call incStack();															// Erhöhe Stack-Pointer
	call nextOperation();														// Lade nächsten Befehl
}

/*
	Addiert die oberen beiden Werte auf dem Stack und schreibt sie als neuen Wert auf den Stack
	Die Beiden Werte, welche addiert werden, werden dabei vom Stack entfernt
*/
function add(0x20) {
	call decStack();															// Veringer den Stack-Pointer um 1
	set op1_register_write(H);													// Schreibe den Wert des Stacks in das erste Operandenregister
	set op1_register_write(H);													// -- TODO: Warum ist diese Zeile notwendig?
	call decStack();															// Veringer den Stack-Pointer um 1
	set op2_register_write(H), math_csel(ADD_U);								// Schreibe den Wert des Stacks in das zweite Operandenregister und schalte die Math-ALU auf addition
	set op2_register_write(H), math_csel(ADD_U);								// -- TODO: Warum ist diese Zeile notwendig?
	set math_csel(ADD_U), stack_port0_isel(math.low), stack_port0_write(H);		// Setze den Stack-Input auf den niederwertigen Math-ALU Ausgang und übernehme den Wert
	call incStack();															// Erhöhe den Stack-Pointer um 1
	call nextOperation();														// Lade nächsten Befehl
}

/*
	Subtrahiert die oberen beiden Werte auf dem Stack und schreibt sie als neuen Wert auf den Stack
	Die Beiden Werte, welche subtrahiert werden, werden dabei vom Stack entfernt
*/
function sub(0x30) {
	call decStack();															// Veringer den Stack-Pointer um 1
	set op1_register_write(H);													// Schreibe den Wert des Stacks in das erste Operandenregister
	set op1_register_write(H);													// -- TODO: Warum ist diese Zeile notwendig?
	call decStack();															// Veringer den Stack-Pointer um 1
	set op2_register_write(H), math_csel(SUB_U);								// Schreibe den Wert des Stacks in das zweite Operandenregister und schalte die Math-ALU auf subtraktion
	set op2_register_write(H), math_csel(SUB_U);								// -- TODO: Warum ist diese Zeile notwendig?
	set math_csel(SUB_U), stack_port0_isel(math.low), stack_port0_write(H);		// Setze den Stack-Input auf den niederwertigen Math-ALU Ausgang und übernehme den Wert
	call incStack();															// Erhöhe den Stack-Pointer um 1
	call nextOperation();														// Lade nächsten Befehl
}

/*
	Multipliziert die oberen beiden Werte auf dem Stack und schreibt sie als neuen Wert auf den Stack
	Die Beiden Werte, welche multipliziert werden, werden dabei vom Stack entfernt
*/
function mul(0x40) {
	call decStack();															// Veringer den Stack-Pointer um 1
	set op1_register_write(H);													// Schreibe den Wert des Stacks in das erste Operandenregister
	set op1_register_write(H);													// -- TODO: Warum ist diese Zeile notwendig?
	call decStack();															// Veringer den Stack-Pointer um 1
	set op2_register_write(H), math_csel(MUL_U);								// Schreibe den Wert des Stacks in das zweite Operandenregister und schalte die Math-ALU auf multiplikation
	set op2_register_write(H), math_csel(MUL_U);								// -- TODO: Warum ist diese Zeile notwendig?
	set math_csel(MUL_U), stack_port0_isel(math.low), stack_port0_write(H);		// Setze den Stack-Input auf den niederwertigen Math-ALU Ausgang und übernehme den Wert
	call incStack();															// Erhöhe den Stack-Pointer um 1
	call nextOperation();														// Lade nächsten Befehl
}

function put(0x50) {
	set output_write(H);
	call nextOperation();
}

/*
	Erhöht den Stack-Pointer um 1
*/
virtual incStack() {
	set stackAlu_csel(ADD_U);													// Berechne Stack-Pointer + 1 mit Stack-Alu
	set stackAlu_csel(ADD_U), stackPtr_isel(stackAlu.out), stackPtr_write(H);	// Wähle Stack-Alu als eingang für den Stack-Pointer und übernehme den Wert
}

/*
	Veringert den Stack-Pointer um 1
*/
virtual decStack() {
	set stackAlu_csel(SUB_U);													// Berechne Stack-Pointer - 1 mit Stack-Alu
	set stackAlu_csel(SUB_U), stackPtr_isel(stackAlu.out), stackPtr_write(H);	// Wähle Stack-Alu als eingang für den Stack-Pointer und übernehme den Wert
}

/*
	Erhöht den Program-Counter um 1
*/
virtual incPc() {
	set pcReg_isel(pcInc.out), pcReg_write(H);									// Wähle Pc-Incrementer für PC + 1 aus und übernehme den Wert
}

/*
	Erhöht den Program-Counter um 1 und lädt den Mikrocode für den nächsten Befehl 
*/
virtual nextOperation() {
	set pcReg_isel(pcInc.out), pcReg_write(H);									// Wähle Pc-Incrementer für PC + 1 aus und übernehme den Wert
	set mpcMux_isel(progMem.out);												// Springe zu Mikrocode für nächsten Befehl
}