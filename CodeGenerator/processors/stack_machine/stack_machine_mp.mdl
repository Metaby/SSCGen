/*
 *	Conventions:
 *	isel = input-select
 *	asel = address-select
 *	csel = command-select
 *
 *	Fields and Parameters:
 *	pcReg_write[0:0] = {H, L}
 *	pcReg_isel[1:1] = {pcInc.out, pcReg.out} *	mpcReg_write[2:2] = {H, L}
 *	mpcReg_isel[3:3] = {mpcInc.out, progMem.out}
 *	op1_register_write[4:4] = {H, L}
 *	op2_register_write[5:5] = {H, L}
 *	stackPtr_write[6:6] = {H, L}
 *	stackPtr_isel[7:7] = {stackAlu.out, stackPtr.out}
 *	output_write[8:8] = {H, L}
 *	stack_port0_isel[9:10] = {math.low, math.high, progMem.out}
 *	stack_port0_write[11:11] = {H, L}
 *	math_csel[12:13] = {ADD_U, MUL_U, SUB_U}
 *	stackAlu_csel[14:14] = {ADD_U, SUB_U}
 */

#include processors/stack_machine/stack_machine_mp_def.mdl

/*
	Initialisierungssequenz fuer die Stack-Maschine
	init:
		-> wird nicht als "function" oder "virtual" definiert und steht immer an "0x00"
		-> muss vorhanden sein
		-> entspricht der "main"-Funktion von anderen Programmiersprachen
		-> wird verwendet um die Architektur zu initialisieren (z.B. boot-loader, perm settings, etc.)
		-> "perm" ist nur in init erlaubt und anders als "fix" global gueltig
*/
init(0x00) {
	perm mpcReg_write(H);
	set mpcReg_isel(progMem.out);
}

/*
	Laedt eine Konstante aus dem Programspeicher
*/
function push(0x10) {
	call incPc();
	call incStack();
	set stack_port0_isel(progMem.out), stack_port0_write(H);
	call nextOperation();
}

/*
	Addiert die oberen beiden Werte auf dem Stack und schreibt sie als neuen Wert auf den Stack
	Die Beiden Werte, welche addiert werden, werden dabei vom Stack entfernt
*/
function add(0x20) {
	set op1_register_write(H);
	call decStack();
	set op2_register_write(H);
	fix math_csel(ADD_U), stack_port0_isel(math.low);
	call incStack();
	set stack_port0_write(H);
	call nextOperation();
}

/*
	Subtrahiert die oberen beiden Werte auf dem Stack und schreibt sie als neuen Wert auf den Stack
	Die Beiden Werte, welche subtrahiert werden, werden dabei vom Stack entfernt
*/
function sub(0x40) {
	//call decStack();
	set op1_register_write(H);
	call decStack();
	set op2_register_write(H);
	fix math_csel(SUB_U), stack_port0_isel(math.low);
	call incStack();
	set stack_port0_write(H);
	call nextOperation();
}

function pop(0x60) {
	set output_write(H), hexdigit_1_custom(H), hexdigit_2_custom(H);
	call decStack();
	call nextOperation();
}

function top(0x70) {
	set output_write(H), hexdigit_1_custom(H), hexdigit_2_custom(H);
	call nextOperation();
}

function addReverse(0x80) {
	set op1_register_write(H);
	call decStack();
	set op2_register_write(H);
	fix math_csel(ADD_U), stack_port0_isel(math.low);
	set stack_port0_write(H);
	call incStack();
	call nextOperation();
}

/*
	Erhoeht den Stack-Pointer um 1
*/
virtual incStack() {
	set stackAlu_csel(ADD_U), stackPtr_isel(stackAlu.out), stackPtr_write(H);
	set noop(0);
}

/*
	Veringert den Stack-Pointer um 1
*/
virtual decStack() {
	set stackAlu_csel(SUB_U), stackPtr_isel(stackAlu.out), stackPtr_write(H);
	set noop(0);
}

/*
	Erhoeht den Program-Counter um 1
*/
virtual incPc() {
	set pcReg_isel(pcInc.out), pcReg_write(H);
}

/*
	Erhoeht den Program-Counter um 1 und laedt den Mikrocode fuer den naechsten Befehl 
*/
virtual nextOperation() {
	call incPc();
	set mpcReg_isel(progMem.out);
}